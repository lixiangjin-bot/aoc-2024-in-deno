## --- 第 3 天：仔细思考 ---

“我们的电脑出了问题，所以我不知道我们是否有库存的首席历史学家！不过，欢迎您去仓库看看，”[北极雪橇租赁店](https://adventofcode.com/2020/day/2)的店主有点慌乱地说。历史学家们出去看看。

店主转身问你：“你能知道为什么我们的电脑又出问题了吗？”

计算机似乎正在尝试运行一个程序，但其内存（您的谜题输入）已*损坏*。所有指令都乱成了一团！

程序的目标似乎只是将*一些数字相乘*。它使用如下指令来实现这一点，`mul(X,Y)`其中`X`和`Y`分别是 1-3 位数字。例如，`mul(44,46)`乘以可得到结果。类似地，乘以。`44``46``2024``mul(123,4)``123``4`

但是，由于程序的内存已被破坏，因此也有许多无效字符应该被*忽略*，即使它们看起来像`mul`指令的一部分。诸如`mul(4*`、`mul(6,9!`、`?(12,34)`或 之类的序列不`mul ( 2 , 4 )`执行*任何操作*。

例如，考虑以下损坏的内存部分：

```
xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))
```

只有四个突出显示的部分是真正的`mul`指令。将每条指令的结果相加得到`*161*`（`2*4 + 5*5 + 11*8 + 8*5`）。

扫描损坏的内存以查找未损坏的`mul`指令。*如果将所有乘法结果相加，会得到什么？*

您的谜题答案是`175700056`。

## --- 第二部分 ---

当你扫描损坏的内存时，你注意到一些条件语句仍然完好无损。如果你处理程序中一些未损坏的条件语句，你可能会得到更准确的结果。

您需要处理两个新指令：

- 该`do()`指令*启用*未来`mul`指令。
- 该`don't()`指令*禁用*未来的`mul`指令。

仅应用*最新的* `do()`或`don't()`指令。在程序开始时，`mul`指令处于*启用状态*。

例如：

```
xmul(2,4)&mul[3,7]!^don't()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))
```

此损坏的内存与之前的示例类似，但这次`mul(5,5)`和`mul(11,8)`指令被*禁用*，因为它们前面有一条`don't()`指令。其他`mul`指令正常运行，包括最后一条指令，该指令由一条指令重新*启用*`do()`。

本次的结果总和为`*48*`（`2*4 + 8*5`）。

处理新指令；*如果将所有启用的乘法结果加起来，会得到什么？*

您的谜题答案是`71668682`。

此拼图的两个部分均已完成！它们提供两颗金星：**

此时，您应该[返回到您的降临节日历](https://adventofcode.com/2024)并尝试另一个谜题。

如果您仍想看到它，您可以[获取您的谜题输入](https://adventofcode.com/2024/day/3/input)。

您还可以[分享]这个谜题。